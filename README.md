# eBPF Profile

This repository is an adaptation of the [eunomia-bpf profile example](https://github.com/eunomia-bpf/bpf-developer-tutorial/blob/main/src/12-profile/README.md), using Go with [cilium/ebpf](https://github.com/cilium/ebpf) library for the userspace code instead of the original Rust implementation.

## Overview

This project demonstrates periodic stack sampling and delivery of stacktrace events to userspace. It captures:
- Per-CPU sampling via perf events
- Kernel- and user-space stack traces
- Process metadata (PID, command name, CPU id, timestamp)

## Key Differences from Original

- **Userspace Language**: Go instead of C
- **BPF Library**: `github.com/cilium/ebpf` instead of libbpf (but `bpf2go` is used for code generation)
- **Trigger mechanism**: perf events + `perf_event_open` to create FDs and attach the eBPF profiling program
- **Ring buffer**: uses a ring buffer map for efficient kernel→userspace event delivery

## Architecture

```
ebpf-profile/
├── bpf/
│   ├── profile.bpf.c      # eBPF kernel program
│   ├── profile.h          # shared event definitions
│   └── vmlinux.h          # kernel types (CO-RE)
├── cmd/
│   └── main.go            # CLI entry point
├── internal/
│   ├── event/
│   │   └── stacktrace_event.go  # event parsing and printing
│   ├── probe/
│   │   ├── probe.go       # eBPF loader, perf event attach, ringbuf reader
│   │   ├── probe_bpfeb.go # generated bindings (big-endian)
│   │   └── probe_bpfel.go # generated bindings (little-endian)
│   └── timer/
│       └── timer.go       # timing helpers
└── Makefile
```

## Requirements

- Linux with BPF & perf support
- clang/llvm and libbpf headers (for building the BPF program via `bpf2go`)
- Go toolchain (1.20+ recommended)
- Root / CAP_BPF privileges to load eBPF programs and create perf FDs

## Installation

```bash
# Clone the repository
git clone <your-repo-url>
cd ebpf-profile

# Install Go deps
go mod download

# Generate eBPF bindings and build
make build
```

## Usage

```bash
# Run with default settings (requires sudo)
sudo ./ebpf-profile

# Examples:
sudo ./ebpf-profile -freq 100          # sample at 100 Hz
sudo ./ebpf-profile -hw                # use PERF_TYPE_HARDWARE
sudo ./ebpf-profile -pid 1234          # profile only PID 1234
sudo ./ebpf-profile -ps                # print stack traces
```

### Command-line Options (common)

- `-freq` : Sampling frequency in Hz (default: 1000000)
- `-hw` : Use hardware perf event (PERF_TYPE_HARDWARE)
- `-pid` : Optional PID filter
- `-ps` : Print stack traces

## Planned features

- Extended folded-format stack printing: upcoming support to print stack traces in an "extended folded" format

## Output Format

```
TIME                 COMM                 PID    CPUID   KStackSz  UStackSz
1761659235300424689  node                 2133   4       0         176 
```

- TIME: Unix timestamp
- COMM: Process command name
- PID: Process id
- CPUID: CPU where sample occurred
- KStackSz / UStackSz: number of bytes captured for kernel/user stacks

## How It Works

### Kernel-Space (eBPF)

The eBPF program (in `bpf/profile.bpf.c`) is attached to perf events. On each sample it:

1. Captures current PID and CPU id
2. Records timestamp
3. Collects kernel and user stacks using `bpf_get_stack`
4. Writes a `stacktrace_event` into a ring buffer map for userspace consumption

### User-Space (Go)

The Go application:

1. Loads the compiled eBPF object (generated by `bpf2go`) using `cilium/ebpf`
2. Creates per-CPU perf event file descriptors via `perf_event_open`
3. Attaches the eBPF program to each perf FD so the kernel runs the program on sampling
4. Reads events from the ring buffer (`events` map), unmarshals them, and prints or forwards them

## Development

Edit `bpf/profile.bpf.c`, then regenerate bindings and rebuild:

```bash
make generate
make build
```

The `//go:generate` directive in `internal/probe/probe.go` runs `bpf2go` to produce the Go bindings and embedded object files.

## Troubleshooting

- If BPF load fails, ensure you run as root and have a compatible kernel.
- If you see `EINVAL` when creating perf events, try adjusting the `PerfEventAttr` size used; some kernels require 120 instead of 112 bytes.
- Ensure `/sys/fs/bpf` is mounted if you pin maps.

## References

- Eunomia example 12 (profile): https://github.com/eunomia-bpf/bpf-developer-tutorial/blob/main/src/12-profile/README.md
- cilium/ebpf: https://github.com/cilium/ebpf
- eBPF docs: https://ebpf.io/

## License

MIT
